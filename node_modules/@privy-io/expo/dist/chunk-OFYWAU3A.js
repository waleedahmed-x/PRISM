"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { newObj[key] = obj[key]; } } } newObj.default = obj; return newObj; } } function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }var rt=Object.defineProperty,ot=Object.defineProperties;var at=Object.getOwnPropertyDescriptors;var he=Object.getOwnPropertySymbols;var nt=Object.prototype.hasOwnProperty,it=Object.prototype.propertyIsEnumerable;var ge=(e,t,o)=>t in e?rt(e,t,{enumerable:!0,configurable:!0,writable:!0,value:o}):e[t]=o,k= exports.a =(e,t)=>{for(var o in t||(t={}))nt.call(t,o)&&ge(e,o,t[o]);if(he)for(var o of he(t))it.call(t,o)&&ge(e,o,t[o]);return e},F= exports.b =(e,t)=>ot(e,at(t));var y=(e,t,o)=>new Promise((r,l)=>{var a=n=>{try{d(o.next(n))}catch(s){l(s)}},c=n=>{try{d(o.throw(n))}catch(s){l(s)}},d=n=>n.done?r(n.value):Promise.resolve(n.value).then(a,c);d((o=o.apply(e,t)).next())});var _expoappleauthentication = require('expo-apple-authentication'); var Ye = _interopRequireWildcard(_expoappleauthentication);var _expoapplication = require('expo-application');var _expolinking = require('expo-linking'); var D = _interopRequireWildcard(_expolinking); var re = _interopRequireWildcard(_expolinking); var M = _interopRequireWildcard(_expolinking); var T = _interopRequireWildcard(_expolinking);var _exposecurestore = require('expo-secure-store'); var A = _interopRequireWildcard(_exposecurestore);var _expowebbrowser = require('expo-web-browser'); var Q = _interopRequireWildcard(_expowebbrowser); var Ie = _interopRequireWildcard(_expowebbrowser);var _react = require('react'); var _react2 = _interopRequireDefault(_react);var _reactnative = require('react-native');var _jssdkcore = require('@privy-io/js-sdk-core'); var _jssdkcore2 = _interopRequireDefault(_jssdkcore);var _expocrypto = require('expo-crypto');var Ee={name:"@privy-io/expo",version:"0.23.0",description:"Expo client for the Privy Auth API",keywords:["authentication","authorization","identity","privacy","privy","user data","react-native","expo","web3"],license:"Apache-2.0",source:"./src/index.ts",main:"./dist/esm/index.js",types:"./dist/index.d.ts",exports:{".":{require:"./dist/index.js",import:"./dist/esm/index.js",types:"./dist/index.d.ts"},"./passkey":{require:"./dist/passkey.js",import:"./dist/esm/passkey.js",types:"./dist/passkey.d.ts"}},files:["dist/**/*","LICENSE","README.md"],scripts:{build:"npx tsup --clean --minify","generate-types":"npx tsup --dts-only",clean:"rm -rf dist .turbo",dev:"npx tsup --watch",test:'jest --testMatch "**/test/**/*.test.ts"',"test:ci":"npm run test",lint:'eslint "src/**/*.{ts,tsx,js,jsx}" && npx tsc --noEmit',format:'eslint "src/**/*.{ts,tsx,js,jsx}" --fix'},peerDependencies:{"@privy-io/expo-native-extensions":"0.0.3",react:"*","react-native":"*","react-native-passkeys":"^0.2.1","react-native-webview":"*","expo-constants":"*","expo-linking":"*","expo-crypto":"*","expo-secure-store":"*","expo-application":"*","expo-apple-authentication":"*","expo-web-browser":"*"},dependencies:{"@privy-io/js-sdk-core":"0.27.0","react-fast-compare":"^3.2.2"},devDependencies:{"@privy-io/eslint-config-custom":"*","@privy-io/tsconfig":"*","@simplewebauthn/types":"9.0.1","@tsconfig/node16-strictest-esm":"^1.0.3",tsup:"^6.2.3",typescript:"~5.5.3"},author:"privy.io",publishConfig:{access:"public"}};var _reactnativewebview = require('react-native-webview'); var _reactnativewebview2 = _interopRequireDefault(_reactnativewebview);var _e=({client:e,isClientReady:t,setWebViewState:o,webViewState:r,logLevel:l})=>{let a=_react.useRef.call(void 0, null);_react.useEffect.call(void 0, ()=>{a.current&&r==="loaded"&&e.setMessagePoster(a.current)},[e,a.current,r==="loaded"]),_react.useEffect.call(void 0, ()=>_reactnative.AppState.addEventListener("change",n=>y(void 0,null,function*(){a.current&&n==="active"&&((yield e.embeddedWallet.ping(500))||(a.current.reload(),o("reloading")))})).remove,[]);let c=_react.useCallback.call(void 0, d=>y(void 0,null,function*(){let{data:n}=d.nativeEvent;e.embeddedWallet.onMessage(JSON.parse(n))}),[e]);return t?_react2.default.createElement(_reactnativewebview2.default,{style:{flex:1},ref:a,source:{uri:e.embeddedWallet.getURL()},webviewDebuggingEnabled:l==="DEBUG",onLoad:()=>o("loaded"),onError:console.error,onMessage:c}):null};function ee(s){return y(this,arguments,function*({client:e,setWallet:t,createWalletCallbacks:o,recoveryMethod:r,setRecoveryFlowState:l,password:a,recoveryToken:c,recoverySecretOverride:d,iCloudRecordNameOverride:n}){var u,p;switch(r){case"user-passcode":if(!a)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"password is required for user-passcode recovery method"});break;case"google-drive":if(!c)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"Recovery token is required for google-drive recovery method"});break;case"icloud":if(!d||!n)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"iCloud recovery failed due to inability to store credentials"});break}t({status:"creating",account:null});let i=r==="icloud"?"icloud-native":r;try{let{provider:f,user:v}=yield e.embeddedWallet.create(a,i,c,d,n),g=_jssdkcore.getUserEmbeddedWallet.call(void 0, v);return(p=(u=o.current)==null?void 0:u.onSuccess)==null||p.call(u,f),t({status:"connected",provider:f,account:g}),l({status:"initial"}),f}catch(f){let v=f instanceof Error?f.message:"Error creating embedded wallet";throw t({status:"error",error:v,account:null}),l({status:"initial"}),new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_creation_error",error:v})}})}function Ce(a){return y(this,arguments,function*({client:e,setSolanaWallet:t,createSolanaWalletCallbacks:o,setSolanaRecoveryFlowState:r,ethereumAccount:l}){var c,d;t({status:"creating"});try{let n=yield e.embeddedWallet.createSolana({ethereumAccount:l});return(d=(c=o.current)==null?void 0:c.onSuccess)==null||d.call(c,n),t({status:"connected",publicKey:n._publicKey}),r({status:"initial"}),n}catch(n){let s=n instanceof Error?n.message:"Error creating embedded wallet";throw t({status:"error",error:s}),r({status:"initial"}),new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_creation_error",error:s})}})}function te(s){return y(this,arguments,function*({client:e,account:t,setWallet:o,recoverWalletCallbacks:r,recoveryMethod:l,setRecoveryFlowState:a,password:c,recoveryToken:d,recoverySecretOverride:n}){var i,u,p,f;if(!t)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});switch(l){case"user-passcode":if(!c)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"password is required for user-passcode recovery method"});break;case"google-drive":if(!d)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"Recovery token is required for google-drive recovery method"});break;case"icloud":if(!n)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"Record name is required for icloud recovery method"});break}o({status:"connecting",account:t});try{let v=yield e.embeddedWallet.getProvider(t,c,d,n);return o({status:"connected",provider:v,account:t}),a({status:"initial"}),(u=(i=r.current)==null?void 0:i.onSuccess)==null||u.call(i,v),v}catch(v){o({status:"needs-recovery",account:t}),a({status:"initial"});let g=new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:v instanceof Error?v.message:"Error recovering embedded wallet"});throw(f=(p=r.current)==null?void 0:p.onError)==null||f.call(p,g),g}})}function ke(a){return y(this,arguments,function*({client:e,solanaAccount:t,setSolanaWallet:o,recoverSolanaWalletCallbacks:r,setSolanaRecoveryFlowState:l}){var c,d,n,s;if(!t)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});o({status:"connecting"});try{let i=yield e.embeddedWallet.getSolanaProvider(t);return o({status:"connected",publicKey:i._publicKey}),l({status:"initial"}),(d=(c=r.current)==null?void 0:c.onSuccess)==null||d.call(c,i),i}catch(i){o({status:"needs-recovery"}),l({status:"initial"});let u=new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:i instanceof Error?i.message:"Error recovering embedded wallet"});throw(s=(n=r.current)==null?void 0:n.onError)==null||s.call(n,u),u}})}var Ae=({client:e,user:t,solanaWallet:o,setSolanaWallet:r,setSolanaRecoveryFlowState:l,webViewState:a,createSolanaWalletCallbacks:c,recoverSolanaWalletCallbacks:d})=>{let n=_react.useMemo.call(void 0, ()=>_jssdkcore.getUserEmbeddedSolanaWallet.call(void 0, t),[t]),s=_react.useCallback.call(void 0, ()=>y(void 0,null,function*(){var v;let{user:p}=yield e.user.get(),f=(v=_jssdkcore.getUserEmbeddedWallet.call(void 0, p))!=null?v:void 0;return yield Ce({client:e,setSolanaWallet:r,createSolanaWalletCallbacks:c,setSolanaRecoveryFlowState:l,ethereumAccount:f})}),[e,c]),i=_react.useCallback.call(void 0, ()=>y(void 0,null,function*(){if(!n)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});return ke({client:e,solanaAccount:n,setSolanaWallet:r,recoverSolanaWalletCallbacks:d,setSolanaRecoveryFlowState:l})}),[e,n]),u=_react.useCallback.call(void 0, ()=>y(void 0,null,function*(){if(!n)throw r({status:"not-created"}),new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});r(p=>p.status==="connected"?{status:"reconnecting"}:{status:"connecting"});try{let p=yield e.embeddedWallet.getSolanaProvider(n);return r({status:"connected",publicKey:p._publicKey}),p}catch(p){throw _jssdkcore.errorIndicatesRecoveryIsNeeded.call(void 0, p)?(r({status:"needs-recovery"}),new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_needs_recovery",error:"Embedded wallet not loaded on device"})):p instanceof Error?(r({status:"error",error:p.message}),new (0, _jssdkcore.PrivyClientError)({code:"unknown_embedded_wallet_error",error:p.message})):(r({status:"error",error:"Error loading embedded wallet"}),new (0, _jssdkcore.PrivyClientError)({code:"unknown_embedded_wallet_error",error:"Error loading embedded wallet"}))}}),[e,n]);return _react.useEffect.call(void 0, ()=>{if(!t&&o.status!=="disconnected")return r({status:"disconnected"});a==="loaded"&&u().catch(()=>{})},[a,t,n]),_react.useEffect.call(void 0, ()=>{o.status==="error"&&o.error.includes("User must be logged in")&&u()},[o.status]),{create:s,recover:i,getProvider:u}};function xe(){return y(this,null,function*(){try{return yield Promise.resolve().then(() => _interopRequireWildcard(require("@privy-io/expo-native-extensions")))}catch(e){throw new Error("@privy-io/expo-native-extensions not found. Ensure that you're explicitly including as a dependency, and running an Expo development build")}})}function ue(r){return y(this,arguments,function*({user:e,appId:t,client:o}){var d;if(_reactnative.Platform.OS==="android")throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"iCloud recovery is not supported on Android"});let l=yield xe(),a=yield o.recovery.icloudAuth.getICloudConfiguration("expo-ios");if(!(a==null?void 0:a.container_identifier))throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"An iCloud Container ID must be specified in the Privy Dashboard."});try{let{recoverySecret:n,iCloudRecordName:s}=yield l.writeRecoverySecretToICloud({containerId:a.container_identifier,appId:t,userId:e.id});return{recoverySecret:n,iCloudRecordName:s}}catch(n){if(n instanceof Error){let s=(d=n.message.split("Caused by: ")[1])!=null?d:"Error writing to iCloud";throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:s})}throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"Error writing to iCloud"})}})}function Pe(o){return y(this,arguments,function*({walletAddress:e,client:t}){var n;if(_reactnative.Platform.OS==="android")throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"iCloud recovery is not supported on Android"});let r=yield xe(),a=(yield t.recovery.getRecoveryKeyMaterial(e)).icloud_record_name;if(!a)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"iCloud recovery not properly backed up."});let c=yield t.recovery.icloudAuth.getICloudConfiguration("expo-ios"),d=c==null?void 0:c.container_identifier;if(!d)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"An iCloud Container ID must be specified in the Privy Dashboard."});try{let{recoverySecret:s}=yield r.readRecoverySecretFromICloud({containerId:d,recordName:a});return{recoverySecret:s}}catch(s){if(s instanceof Error){let i=(n=s.message.split("Caused by: ")[1])!=null?n:"Error writing to iCloud";throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:i})}throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"Error writing to iCloud"})}})}var _reactfastcompare = require('react-fast-compare'); var _reactfastcompare2 = _interopRequireDefault(_reactfastcompare);var Ue=e=>t=>e(o=>_reactfastcompare2.default.call(void 0, o,t)?o:t);function R(e){return e instanceof Error||e instanceof _jssdkcore.PrivyApiError||e instanceof _jssdkcore.PrivyClientError?e:typeof e=="string"?new Error(e):new Error("Unknown error")}var Cr=e=>new Promise(t=>setTimeout(t,e));function xr(){let e=_react.useRef.call(void 0, _reactnative.AppState.currentState);_react.useEffect.call(void 0, ()=>_reactnative.AppState.addEventListener("change",r=>{e.current=r}).remove,[]);function t(){return _reactnative.AppState.currentState}return{appState:e,getCurrentAppState:t}}function oe(l){return y(this,arguments,function*({provider:e,redirectUri:t,client:o,onError:r}){try{let a;switch(e){case"google-drive":{let{url:s}=yield o.recovery.auth.generateURL(re.createURL(t||"/"));a=s;break}default:throw new (0, _jssdkcore.PrivyClientError)({error:"OAuth invalid provider",code:"embedded_wallet_recovery_error"})}let c=yield Ie.openAuthSessionAsync(a);if(_reactnative.Platform.OS==="android")return;if(c.type!=="success")throw new (0, _jssdkcore.PrivyClientError)({error:"Recovery OAuth session failed",code:"embedded_wallet_recovery_error"});let{queryParams:d}=re.parse(c.url),n;switch(e){case"google-drive":{let{privy_oauth_state:s,privy_oauth_code:i}=d;if(!i||!s)throw new (0, _jssdkcore.PrivyClientError)({error:"Recovery OAuth invalid credentials",code:"embedded_wallet_recovery_error"});n=yield me({oAuthCode:i,oAuthState:s,client:o});break}default:throw new (0, _jssdkcore.PrivyClientError)({error:"Recovery OAuth invalid provider",code:"embedded_wallet_recovery_error"})}return n}catch(a){throw r==null||r(R(a)),a}})}function me(r){return y(this,arguments,function*({oAuthCode:e,oAuthState:t,client:o}){let{access_token:l}=yield o.recovery.auth.authorize(e,t);if(!l)throw new (0, _jssdkcore.PrivyClientError)({error:"OAuth invalid credentials",code:"login_with_oauth_returned_with_invalid_credentials"});return l})}function ae(a){return y(this,arguments,function*({client:e,recoveryInput:t,setWalletRecoveryCallbacks:o,setRecoveryFlowState:r,setWallet:l}){var c,d,n,s;try{let{provider:i,user:u}=yield e.embeddedWallet.setRecovery(t),p=_jssdkcore.getUserEmbeddedWallet.call(void 0, u);return l({status:"connected",provider:i,account:p}),(d=(c=o.current)==null?void 0:c.onSuccess)==null||d.call(c,i),r({status:"initial"}),i}catch(i){let u=new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_set_recovery_error",error:i instanceof Error?i.message:"Error setting password on embedded wallet"});throw(s=(n=o.current)==null?void 0:n.onError)==null||s.call(n,u),r({status:"initial"}),u}})}function Fe(e){return e===void 0?{recoveryMethod:"privy"}:typeof e=="string"?{recoveryMethod:"user-passcode",password:e}:e.recoveryMethod==="user-passcode"?{recoveryMethod:"user-passcode",password:e.password}:{recoveryMethod:e.recoveryMethod}}var Me=({client:e,user:t,appId:o,wallet:r,setWallet:l,setRecoveryFlowState:a,webViewState:c,createWalletCallbacks:d,recoverWalletCallbacks:n,setWalletRecoveryCallbacks:s})=>{let i=_react.useMemo.call(void 0, ()=>_jssdkcore.getUserEmbeddedWallet.call(void 0, t),[t]),u=_react.useCallback.call(void 0, m=>y(void 0,null,function*(){var P;if(i)throw new (0, _jssdkcore.PrivyClientError)({error:"This user already has an embedded wallet",code:"embedded_wallet_already_exists"});let{password:S,recoveryMethod:b}=Fe(m),h,w,E;if(b==="google-drive"&&(h=yield oe({provider:b,client:e,onError:(P=d.current)==null?void 0:P.onError}),a({status:"creating-wallet"}),!h))return null;if(b==="icloud"){if(!t)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"User must be loaded before creating a wallet with iCloud."});let{recoverySecret:O,iCloudRecordName:N}=yield ue({user:t,appId:o,client:e});w=O,E=N}return yield ee({client:e,setWallet:l,createWalletCallbacks:d,recoveryMethod:b,setRecoveryFlowState:a,password:S,recoverySecretOverride:w,iCloudRecordNameOverride:E})}),[e,i,t]),p=_react.useCallback.call(void 0, m=>y(void 0,null,function*(){var h;if(r.status!=="connected")throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_to_set_password_before_connected",error:"Embedded wallet must be connected before setting password"});if(!i)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});_jssdkcore.throwIfInvalidRecoveryUpgradePath.call(void 0, {currentRecoveryMethod:i.recovery_method,upgradeToRecoveryMethod:m.recoveryMethod});let S,b;switch(m.recoveryMethod){case"privy":b=F(k({},m),{wallet:i});break;case"user-passcode":b=F(k({},m),{wallet:i,password:m.password});break;case"google-drive":if(S=yield oe({provider:m.recoveryMethod,client:e,onError:(h=s.current)==null?void 0:h.onError}),a({status:"upgrading-recovery"}),!S)return null;b={recoveryMethod:"google-drive",wallet:i,recoveryAccessToken:S};break;case"icloud":if(!t)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"User must be loaded before backing up to iCloud."});let{recoverySecret:w,iCloudRecordName:E}=yield ue({user:t,appId:o,client:e});b={recoveryMethod:"icloud-native",recoverySecretOverride:w,iCloudRecordNameOverride:E,wallet:i};break;default:throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"Unrecognized recovery method"})}return ae({client:e,recoveryInput:b,setWalletRecoveryCallbacks:s,setRecoveryFlowState:a,setWallet:l})}),[e,i,r.status,t]),f=_react.useCallback.call(void 0, m=>y(void 0,null,function*(){return p({recoveryMethod:"user-passcode",password:m})}),[e,i,r.status]),v=_react.useCallback.call(void 0, m=>y(void 0,null,function*(){var E;if(!i)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});let{password:S,recoveryMethod:b}=Fe(m),h,w;if(b==="google-drive"&&(h=yield oe({provider:b,client:e,onError:(E=n.current)==null?void 0:E.onError}),a({status:"recovering"}),!h))return null;if(b==="icloud"){if(!t)throw new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_recovery_error",error:"User must be loaded before recovering via iCloud."});let{recoverySecret:P}=yield Pe({client:e,walletAddress:i.address});w=P}return te({client:e,account:i,setWallet:l,recoverWalletCallbacks:n,recoveryMethod:b,setRecoveryFlowState:a,password:S,recoveryToken:h,recoverySecretOverride:w})}),[e,i]),g=_react.useCallback.call(void 0, ()=>y(void 0,null,function*(){if(!i)throw l({status:"not-created",account:null}),new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_does_not_exist",error:"Embedded wallet does not exist"});l(m=>m.status==="connected"?{status:"reconnecting",account:i}:{status:"connecting",account:i});try{let m=yield e.embeddedWallet.getProvider(i);return l({status:"connected",provider:m,account:i}),m}catch(m){throw _jssdkcore.errorIndicatesRecoveryIsNeeded.call(void 0, m)?(l({status:"needs-recovery",account:i}),new (0, _jssdkcore.PrivyClientError)({code:"embedded_wallet_needs_recovery",error:"Embedded wallet not loaded on device"})):m instanceof Error?(l({status:"error",error:m.message,account:i}),new (0, _jssdkcore.PrivyClientError)({code:"unknown_embedded_wallet_error",error:m.message})):(l({status:"error",error:"Error loading embedded wallet",account:i}),new (0, _jssdkcore.PrivyClientError)({code:"unknown_embedded_wallet_error",error:"Error loading embedded wallet"}))}}),[e,i]);return _react.useEffect.call(void 0, ()=>{if(!t&&r.status!=="disconnected")return l({status:"disconnected",account:null});c==="loaded"&&g().catch(()=>{})},[c,t,i]),_react.useEffect.call(void 0, ()=>{r.status==="error"&&r.error.includes("User must be logged in")&&g()},[r.status]),{create:u,recover:v,setPassword:f,setRecovery:p,getProvider:g}};var je=({client:e,user:t,isReady:o,customAuth:r})=>{let[l,a]=_react.useState.call(void 0, {status:"initial"});return _react.useEffect.call(void 0, ()=>{(()=>y(void 0,null,function*(){if(!(r!=null&&r.enabled)){a({status:"not-enabled"});return}a({status:"loading"});let{getCustomAccessToken:d,isLoading:n}=r;if(!(!o||n))try{let s=yield d();if(!s&&t){yield e.auth.logout(),a({status:"done"});return}if(!s){a({status:"done"});return}if(t){a({status:"done"});return}if(!(yield e.auth.customProvider.syncWithToken(s))){yield e.auth.logout(),a({status:"error",error:new (0, _jssdkcore.PrivyClientError)({error:"Failed to sync with custom auth provider",code:"third_party_auth_error"})});return}a({status:"done"})}catch(s){if(console.log("Error syncing with custom auth provider",s),a({status:"error",error:s}),t)throw yield e.auth.logout(),new (0, _jssdkcore.PrivyClientError)({error:"Third-party auth failed",code:"third_party_auth_error"})}}))()},[e,t,o,r==null?void 0:r.enabled,r==null?void 0:r.getCustomAccessToken,r==null?void 0:r.isLoading]),{customAuthState:l,customAuthStateIsSettled:l.status!=="loading"&&l.status!=="initial"}};var De=({client:e,user:t,isUserInitialized:o,oAuthState:r,oAuthCallbacks:l,setOAuthState:a,recoveryFlowState:c,oAuthStateRef:d})=>{let n=M.useURL(),s=_react.useCallback.call(void 0, i=>{var p,f;let u=R(i);a({status:"error",error:u}),(f=(p=l.current).onError)==null||f.call(p,u)},[a]);return _react.useEffect.call(void 0, ()=>{function i(){return y(this,null,function*(){var v,g;if(!n||r.status!=="loading"||c.status!=="initial")return;let{queryParams:u}=M.parse(n),{privy_oauth_state:p,privy_oauth_code:f}=u;if(!f||!p){a({status:"done"});return}try{let m,S;if(t)m=yield e.auth.oauth.linkWithCode(f,p);else{let b=yield e.auth.oauth.loginWithCode(f,p,void 0,void 0,d.current.disableSignup?"no-signup":"login-or-sign-up");m=b.user,S=!!b.is_new_user}return(g=(v=l.current).onSuccess)==null||g.call(v,m,S),d.current={},a({status:"done"}),yield M.openURL(n.split("?")[0])}catch(m){d.current={},s(m)}})}_reactnative.Platform.OS==="android"&&o&&i()},[n,o])};var Ne=({client:e,user:t,createWalletCallbacks:o,recoverWalletCallbacks:r,setWalletRecoveryCallbacks:l,recoveryFlowState:a,oAuthState:c,setRecoveryFlowState:d,setWallet:n,appStateVisible:s,webViewLoaded:i})=>{let u=T.useURL(),p=_react.useMemo.call(void 0, ()=>_jssdkcore.getUserEmbeddedWallet.call(void 0, t),[t]),f=_react.useCallback.call(void 0, v=>{var m,S,b,h;let g=R(v);a.status==="creating-wallet"?(S=(m=o.current).onError)==null||S.call(m,R(g)):(h=(b=r.current).onError)==null||h.call(b,R(g)),d({status:"initial"})},[a]);return _react.useEffect.call(void 0, ()=>{function v(){return y(this,null,function*(){if(!u&&a.status!=="initial"&&s&&f(new Error("Recovery OAuth session failed")),!u||a.status==="initial"||c.status!=="initial"||!s||!i)return;let{queryParams:g}=T.parse(u),{privy_oauth_state:m,privy_oauth_code:S}=g;if(!(!S||!m)){yield T.openURL(u.split("?")[0]);try{let b=yield me({oAuthCode:S,oAuthState:m,client:e});if(a.status==="creating-wallet")yield ee({client:e,setWallet:n,createWalletCallbacks:o,recoveryMethod:"google-drive",setRecoveryFlowState:d,recoveryToken:b});else if(a.status==="upgrading-recovery"){if(!p)throw new Error("Embedded wallet not found");yield ae({client:e,recoveryInput:{recoveryMethod:"google-drive",wallet:p,recoveryAccessToken:b},setWalletRecoveryCallbacks:l,setRecoveryFlowState:d,setWallet:n})}else yield te({client:e,account:p,setWallet:n,recoverWalletCallbacks:r,recoveryMethod:"google-drive",setRecoveryFlowState:d,recoveryToken:b})}catch(b){f(b)}}})}_reactnative.Platform.OS==="android"&&v()},[u,a.status,s,i])};var Ve=({client:e,isUserInitialized:t,setIsUserInitialized:o})=>{_react.useEffect.call(void 0, ()=>{t||(()=>y(void 0,null,function*(){try{yield e.user.get()}catch(l){}finally{o(!0)}}))()},[t])};var ye=_react.createContext.call(void 0, {}),ie;function Do(){return ie?ie.getAccessToken():Promise.resolve(null)}var No=e=>{var we;let[t,o]=_react.useState.call(void 0, _reactnative.AppState.currentState==="active");_react.useEffect.call(void 0, ()=>{let L=_reactnative.AppState.addEventListener("change",tt=>{o(tt==="active")});return()=>{L.remove()}},[]);let[r,l]=_react.useState.call(void 0, !1),[a,c]=_react.useState.call(void 0, "loading"),[d,n]=_react.useState.call(void 0, !1),[s,i]=_react.useState.call(void 0, null),[u,p]=_react.useState.call(void 0, {status:"disconnected",account:null}),[f,v]=_react.useState.call(void 0, {status:"disconnected"}),[g,m]=_react.useState.call(void 0, {status:"initial"}),[S,b]=_react.useState.call(void 0, {status:"initial"}),h=_react.useRef.call(void 0, {}),[w,E]=_react.useState.call(void 0, {status:"initial"}),[P,O]=_react.useState.call(void 0, {status:"initial"}),[N,V]=_react.useState.call(void 0, {status:"initial"}),[z,H]=_react.useState.call(void 0, {status:"initial"}),[q,B]=_react.useState.call(void 0, {status:"initial"}),K=_react.useRef.call(void 0, {}),de=_react.useRef.call(void 0, {}),se=_react.useRef.call(void 0, {}),le=_react.useRef.call(void 0, {}),fe=_react.useRef.call(void 0, {}),Se=_react.useRef.call(void 0, {}),Z=_react.useCallback.call(void 0, L=>{if(L)return Ue(i)(L);i(null),m({status:"initial"}),b({status:"initial"}),p({status:"disconnected",account:null})},[]),W=_react.useMemo.call(void 0, ()=>{let L=e.storage||Ke;return ie=new (0, _jssdkcore2.default)({storage:Be(L),appId:e.appId,clientId:e.clientId,supportedChains:e.supportedChains,nativeAppIdentifier:qe(),baseUrl:e.baseUrl,sdkVersion:`expo:${Ee.version}`,callbacks:{setUser:Z,setIsReady:n},logLevel:e.logLevel,crypto:{digest:_expocrypto.digest}}),ie},[e.storage,e.appId,e.clientId,e.baseUrl,e.supportedChains,e.logLevel,Z]),Xe=_react.useCallback.call(void 0, ()=>(Z(null),W.auth.logout()),[Z,W]),Je=_react.useCallback.call(void 0, ()=>W.getAccessToken(),[W]),$e=_react.useCallback.call(void 0, ()=>W.getIdentityToken(),[W]);Ve({client:W,isUserInitialized:r,setIsUserInitialized:l});let Qe=Me({client:W,user:s,appId:e.appId,webViewState:a,createWalletCallbacks:de,recoverWalletCallbacks:se,setWalletRecoveryCallbacks:le,setRecoveryFlowState:E,wallet:u,setWallet:p}),Ze=Ae({client:W,user:s,webViewState:a,createSolanaWalletCallbacks:fe,recoverSolanaWalletCallbacks:Se,setSolanaRecoveryFlowState:O,solanaWallet:f,setSolanaWallet:v});De({client:W,isUserInitialized:r,user:s,oAuthState:S,setOAuthState:b,oAuthCallbacks:K,recoveryFlowState:w,oAuthStateRef:h}),Ne({client:W,user:s,webViewLoaded:a==="loaded",createWalletCallbacks:de,recoverWalletCallbacks:se,setWalletRecoveryCallbacks:le,recoveryFlowState:w,oAuthState:S,setRecoveryFlowState:E,setWallet:p,appStateVisible:t});let{customAuthStateIsSettled:et}=je({client:W,user:s,isReady:r,customAuth:(we=e.config)==null?void 0:we.customAuth});return _react2.default.createElement(_react2.default.Fragment,null,_react2.default.createElement(ye.Provider,{value:{client:W,user:s,isReady:a!=="loading"&&r&&He(S)&&et,logout:Xe,getAccessToken:Je,getIdentityToken:$e,wallet:k(k({},u),Qe),solanaWallet:k(k({},f),Ze),oAuthState:S,oAuthCallbacks:K,recoveryFlowState:w,setRecoveryFlowState:E,solanaRecoveryFlowState:P,setSolanaRecoveryFlowState:O,createWalletCallbacks:de,recoverWalletCallbacks:se,setWalletRecoveryCallbacks:le,createSolanaWalletCallbacks:fe,recoverSolanaWalletCallbacks:Se,setOAuthState:b,siweState:N,setSiweState:V,otpState:g,setOtpState:m,passkeyState:z,setPasskeyState:H,farcasterState:q,setFarcasterState:B,oAuthStateRef:h}},e.children),_react2.default.createElement(_reactnative.View,{style:{width:0,height:0,overflow:"hidden"}},_react2.default.createElement(_e,{logLevel:e.logLevel,client:W,isClientReady:d,setWebViewState:c,webViewState:a})))};var He=e=>e.status!=="loading",ve=(e={})=>{let{user:t,oAuthState:o,setOAuthState:r,oAuthCallbacks:l,client:a,oAuthStateRef:c}=_react.useContext.call(void 0, ye),d=e.action?e.action==="login":!t;_react.useEffect.call(void 0, ()=>{l.current={onSuccess:e.onSuccess,onError:e.onError}},[e.onSuccess,e.onError]);let n=_react.useCallback.call(void 0, i=>{var p;let u=R(i);return r({status:"error",error:u}),(p=e==null?void 0:e.onError)==null||p.call(e,u),u},[e==null?void 0:e.onError]);return{start:_react.useCallback.call(void 0, function(g){return y(this,arguments,function*({provider:u,redirectUri:p,isLegacyAppleIosBehaviorEnabled:f=!1,disableSignup:v}){var m,S,b;r({status:"loading"}),c.current={disableSignup:v};try{if(t&&e.action==="login")throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_login_with_oauth_while_already_logged_in",error:"Already logged in, if trying to link an OAuth account use `useLinkWithOAuth`"});if(!t&&e.action==="link")throw new (0, _jssdkcore.PrivyClientError)({code:"attempted_link_oauth_before_logged_in",error:"Must be logged in to link an OAuth account, use `useLoginWithOAuth`"});let{url:h}=yield a.auth.oauth.generateURL(u,D.createURL(p||"/")),w,E;if(_reactnative.Platform.OS==="ios"&&u==="apple"&&!f){let q=(m=new URL(h).searchParams.get("state"))!=null?m:"",B=yield Ye.signInAsync({state:q});if(!B.authorizationCode)throw new (0, _jssdkcore.PrivyClientError)({error:"OAuth invalid credentials",code:d?"login_with_oauth_returned_with_invalid_credentials":"link_with_oauth_returned_with_invalid_credentials"});if(d){let K=yield a.auth.oauth.loginWithCode(B.authorizationCode,q,u,"raw",v?"no-signup":"login-or-sign-up");w=K.user,E=K.is_new_user}else w=yield a.auth.oauth.linkWithCode(B.authorizationCode,q,u,"raw");return(S=e==null?void 0:e.onSuccess)==null||S.call(e,w,E),r({status:"done"}),w!=null?w:void 0}let P=_reactnative.Platform.OS==="android"?h.replace("x.com","twitter.com"):h,O=yield Q.openAuthSessionAsync(P);if(_reactnative.Platform.OS==="android")return;if(O.type!=="success")throw[Q.WebBrowserResultType.CANCEL,Q.WebBrowserResultType.DISMISS].includes(O.type)?new (0, _jssdkcore.PrivyClientError)({error:"OAuth was cancelled",code:d?"login_with_oauth_was_cancelled_by_user":"link_with_oauth_was_cancelled_by_user"}):new (0, _jssdkcore.PrivyClientError)({error:"OAuth session failed",code:d?"failed_to_complete_login_with_oauth":"failed_to_complete_link_with_oauth"});let{queryParams:N}=D.parse(O.url),{privy_oauth_state:V,privy_oauth_code:z}=N;if(!z||!V)throw new (0, _jssdkcore.PrivyClientError)({error:"OAuth invalid credentials",code:d?"login_with_oauth_returned_with_invalid_credentials":"link_with_oauth_returned_with_invalid_credentials"});if(d){let H=yield a.auth.oauth.loginWithCode(z,V,u,void 0,v?"no-signup":"login-or-sign-up");w=H.user,E=H.is_new_user}else w=yield a.auth.oauth.linkWithCode(z,V,u);return(b=e==null?void 0:e.onSuccess)==null||b.call(e,w,E),yield D.openURL(O.url.split("?")[0]),r({status:"done"}),w!=null?w:void 0}catch(h){n(h)}})},[t,a,r,n]),state:o}};function Xo(e){let{state:t,start:o}=ve(F(k({},e),{action:"login"}));return{state:t,login:o}}function Jo(e){let{state:t,start:o}=ve(F(k({},e),{action:"link"}));return{state:t,link:o}}function $o(e){return ve(e)}var qe=()=>_expoapplication.applicationId;function Be(e){return{get(t){return e.get(t.replaceAll(":","-"))},put(t,o){return e.put(t.replaceAll(":","-"),o)},del(t){return e.del(t.replaceAll(":","-"))},getKeys:()=>y(this,null,function*(){return[]})}}var Ke={get(e){return A.getItemAsync(e,{keychainAccessible:A.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY})},put(e,t){return A.setItemAsync(e,t,{keychainAccessible:A.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY})},del(e){return A.deleteItemAsync(e,{keychainAccessible:A.AFTER_FIRST_UNLOCK_THIS_DEVICE_ONLY})},getKeys:()=>y(void 0,null,function*(){return[]})};function ea(e){return e.status==="connected"}function ta(e){return e.status==="reconnecting"}function ra(e){return e.status==="connecting"}function oa(e){return e.status==="disconnected"}function aa(e){return e.status==="not-created"}function na(e){return e.status==="creating"}function ia(e){return e.status==="error"}function da(e){return e.status==="needs-recovery"}exports.a = k; exports.b = F; exports.c = y; exports.d = R; exports.e = Cr; exports.f = xr; exports.g = Xo; exports.h = Jo; exports.i = $o; exports.j = Ke; exports.k = ye; exports.l = Do; exports.m = No; exports.n = ea; exports.o = ta; exports.p = ra; exports.q = oa; exports.r = aa; exports.s = na; exports.t = ia; exports.u = da;
