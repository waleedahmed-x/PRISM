import * as Privy from '@privy-io/js-sdk-core';
import Privy__default, { OAuthProviderType, PrivyEmbeddedWalletProvider, PrivyEmbeddedSolanaWalletProvider, Storage, Chain } from '@privy-io/js-sdk-core';
export * from '@privy-io/js-sdk-core';
import React from 'react';
import * as _privy_io_public_api from '@privy-io/public-api';
import { PrivyUser } from '@privy-io/public-api';
import { A as AuthLinkSuccessCallback, G as GenerateSiweMessage, S as SiweFlowState, E as ErrorCallback$1, a as AuthSuccessCallback, O as OtpLinkHookOptions, b as OtpLinkHookResult, c as OtpLoginHookOptions, d as OtpLoginHookResult, F as FarcasterFlowState, L as LinkFarcasterInput, e as SubmitFarcasterOptions, f as LoginWithFarcasterInput, g as OAuthHookOptions, h as EmbeddedWalletState, i as EmbeddedSolanaWalletState, j as OtpFlowState, k as OAuthFlowState, W as WalletRecoveryCallbacks, l as SolanaWalletRecoveryCallbacks, R as RecoveryFlowState, P as PasskeyFlowState } from './predicates-3185ef09.js';
export { C as CreateOrRecoverEmbeddedWalletProps, o as CustomAuthFlowState, r as EmbeddedSolanaWalletActions, s as EmbeddedSolanaWalletStatus, m as EmbeddedWallet, p as EmbeddedWalletActions, q as EmbeddedWalletStatus, n as SetRecoveryProps, U as User, z as hasError, t as isConnected, v as isConnecting, y as isCreating, w as isDisconnected, x as isNotCreated, u as isReconnecting, B as needsRecovery } from './predicates-3185ef09.js';

type CustomAuthProviderConfig = {
    /**
     * If true, enable custom authentication integration.
     * This enables a JWT from a custom auth provider to be used to authenticate Privy embedded wallets.
     * Defaults to true.
     *
     * @default true
     */
    enabled?: boolean;
    /**
     * A callback that returns the user's custom auth provider's access token as a string.
     * Can be left blank if using cookies to store and send access tokens
     *
     * @example
     * const {getAccessTokenSilently} = useAuth();
     *
     * <PrivyProvider
     *   {...props}
     *   config={{
     *     customAuth: {
     *       getCustomAccessToken: getAccessTokenSilently
     *     },
     *   }}
     * />
     */
    getCustomAccessToken: () => Promise<string | undefined>;
    /**
     * Custom auth providers loading state
     *
     * @example
     * const {isLoading} = useAuth();
     *
     * <PrivyProvider
     *   {...props}
     *   config={{
     *     customAuth: {
     *       isLoading,
     *     },
     *   }}
     * />
     */
    isLoading: boolean;
};

interface UseLinkWithSiweOptions {
    onError?: ErrorCallback;
    onSuccess: AuthLinkSuccessCallback;
    onGenerateMessage?: (args: string) => void;
}
interface UseLinkWithSiwe {
    generateSiweMessage: GenerateSiweMessage;
    state: SiweFlowState;
    linkWithSiwe: (opts: {
        /** Signature generated against standard [Sign-In With Ethereum](https://eips.ethereum.org/EIPS/eip-4361) message */
        signature: string;
        /**
         * Optional [Sign-In With Ethereum](https://eips.ethereum.org/EIPS/eip-4361) message, only needed if the message differs from the one in memory that was cached in previous call to `generateMessage`
         */
        messageOverride?: string;
    }) => Promise<PrivyUser>;
}
declare const useLinkWithSiwe: (opts?: UseLinkWithSiweOptions) => UseLinkWithSiwe;

interface UseLoginWithSiweOptions {
    onError?: ErrorCallback$1;
    onSuccess: AuthSuccessCallback;
    onGenerateMessage?: (args: string) => void;
}
interface UseLoginWithSiwe {
    generateSiweMessage: GenerateSiweMessage;
    state: SiweFlowState;
    loginWithSiwe: (opts: {
        /** Signature generated against standard [Sign-In With Ethereum](https://eips.ethereum.org/EIPS/eip-4361) message */
        signature: string;
        /**
         * Optional [Sign-In With Ethereum](https://eips.ethereum.org/EIPS/eip-4361) message, only needed if the message differs from the one in memory that was cached in previous call to `generateMessage`
         */
        messageOverride?: string;
        disableSignup?: boolean;
    }) => Promise<PrivyUser>;
}
declare const useLoginWithSiwe: (opts?: UseLoginWithSiweOptions) => UseLoginWithSiwe;

interface UseUnlinkWalletOptions {
    onError?: ErrorCallback;
    onSuccess: AuthSuccessCallback;
    onGenerateMessage?: (args: string) => void;
}
interface UseUnlinkWallet {
    unlinkWallet: (opts: {
        address: string;
    }) => Promise<PrivyUser>;
}
declare const useUnlinkWallet: (opts?: UseUnlinkWalletOptions) => UseUnlinkWallet;

type LinkWithEmailOptions = OtpLinkHookOptions<{
    email: string;
}>;
type LinkWithEmailHookResult = OtpLinkHookResult<{
    email: string;
}, {
    code: string;
    email?: string;
}>;
declare const useLinkEmail: (opts?: LinkWithEmailOptions) => LinkWithEmailHookResult;

type LoginWithEmailOptions = OtpLoginHookOptions<{
    email: string;
}>;
type LoginWithEmailHookResult = OtpLoginHookResult<{
    email: string;
}, {
    code: string;
    email?: string;
    disableSignup?: boolean;
}>;
declare const useLoginWithEmail: (opts?: LoginWithEmailOptions) => LoginWithEmailHookResult;

type LinkWithSMSOptions = OtpLinkHookOptions<{
    phone: string;
}>;
type LinkWithSMSHookResult = OtpLinkHookResult<{
    phone: string;
}, {
    code: string;
    phone?: string;
}>;
declare const useLinkSMS: (opts?: LinkWithSMSOptions) => LinkWithSMSHookResult;

type LoginWithSMSOptions = OtpLoginHookOptions<{
    phone: string;
}>;
type LoginWithSMSHookResult = OtpLoginHookResult<{
    phone: string;
}, {
    code: string;
    phone?: string;
    disableSignup?: boolean;
}>;
declare const useLoginWithSMS: (opts?: LoginWithSMSOptions) => LoginWithSMSHookResult;

interface UseLinkWithFarcasterOptions {
    onSuccess: AuthLinkSuccessCallback;
    onError?: ErrorCallback;
}
interface UseLinkWithFarcaster {
    state: FarcasterFlowState;
    linkWithFarcaster: (input: LinkFarcasterInput, opts?: SubmitFarcasterOptions) => Promise<PrivyUser>;
    cancel: (_?: void) => void;
}
declare const useLinkWithFarcaster: (opts?: UseLinkWithFarcasterOptions) => UseLinkWithFarcaster;

interface UseUnlinkFarcasterOptions {
    onSuccess: AuthLinkSuccessCallback;
    onError?: ErrorCallback;
}
interface UseUnlinkFarcaster {
    unlinkFarcaster: (input: {
        fid: number;
    }) => Promise<PrivyUser>;
}
declare const useUnlinkFarcaster: (opts?: UseUnlinkFarcasterOptions) => UseUnlinkFarcaster;

interface UseLoginWithFarcasterOptions {
    onSuccess: AuthSuccessCallback;
    onError?: ErrorCallback$1;
}
interface UseLoginWithFarcaster {
    state: FarcasterFlowState;
    loginWithFarcaster: (input: LoginWithFarcasterInput, opts?: SubmitFarcasterOptions) => Promise<PrivyUser>;
    cancel: (_?: void) => void;
}
declare const useLoginWithFarcaster: (opts?: UseLoginWithFarcasterOptions) => UseLoginWithFarcaster;

declare const useUnlinkOAuth: (opts?: OAuthHookOptions) => {
    unlinkOAuth: ({ provider, subject }: {
        provider: OAuthProviderType;
        subject: string;
    }) => Promise<{
        id: string;
        mfa_methods: ({
            type: "sms";
            verified_at: number;
        } | {
            type: "totp";
            verified_at: number;
        } | {
            type: "passkey";
            verified_at: number;
        })[];
        linked_accounts: ({
            type: "email";
            address: string;
            verified_at: number;
            first_verified_at: number | null;
            latest_verified_at: number | null;
        } | {
            type: "phone";
            phoneNumber: string;
            verified_at: number;
            first_verified_at: number | null;
            latest_verified_at: number | null;
        } | {
            type: "wallet";
            address: string;
            chain_type: "ethereum";
            verified_at: number;
            first_verified_at: number | null;
            latest_verified_at: number | null;
            wallet_client: "unknown";
            chain_id?: string | undefined;
            wallet_client_type?: string | undefined;
            connector_type?: string | undefined;
        } | {
            type: "wallet";
            address: string;
            chain_type: "solana";
            verified_at: number;
            first_verified_at: number | null;
            latest_verified_at: number | null;
            wallet_client: "unknown";
            wallet_client_type?: string | undefined;
            connector_type?: string | undefined;
        } | {
            type: "farcaster";
            fid: number;
            verified_at: number;
            first_verified_at: number | null;
            latest_verified_at: number | null;
            owner_address: string;
            username?: string | undefined;
            display_name?: string | undefined;
            bio?: string | undefined;
            profile_picture?: string | undefined;
            profile_picture_url?: string | undefined;
            homepage_url?: string | undefined;
            signer_public_key?: string | undefined;
        } | {
            type: "passkey";
            credential_id: string;
            verified_at: number;
            first_verified_at: number | null;
            latest_verified_at: number | null;
            enrolled_in_mfa: boolean;
            created_with_browser?: string | undefined;
            created_with_os?: string | undefined;
            created_with_device?: string | undefined;
            authenticator_name?: string | undefined;
        } | {
            telegramUserId: string;
            firstName: string | null | undefined;
            type: "telegram";
            verified_at: number;
            first_verified_at: number | null;
            latest_verified_at: number | null;
            telegram_user_id: string;
            username?: string | null | undefined;
            first_name?: string | null | undefined;
            last_name?: string | null | undefined;
            photo_url?: string | null | undefined;
        } | {
            type: "wallet";
            address: string;
            chain_type: "ethereum";
            verified_at: number;
            first_verified_at: number | null;
            latest_verified_at: number | null;
            chain_id: "eip155:1";
            wallet_client: "privy";
            wallet_client_type: "privy";
            connector_type: "embedded";
            imported: boolean;
            wallet_index: number;
            recovery_method: "user-passcode" | "google-drive" | "icloud" | "privy";
        } | {
            type: "wallet";
            address: string;
            public_key: string;
            chain_type: "solana";
            verified_at: number;
            first_verified_at: number | null;
            latest_verified_at: number | null;
            chain_id: "solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp";
            wallet_client_type: "privy";
            connector_type: "embedded";
            imported: boolean;
            recovery_method: "privy";
        } | {
            type: "google_oauth";
            name: string | null;
            email: string;
            subject: string;
            verified_at: number;
            first_verified_at: number | null;
            latest_verified_at: number | null;
        } | {
            type: "twitter_oauth";
            name: string | null;
            username: string | null;
            subject: string;
            verified_at: number;
            first_verified_at: number | null;
            latest_verified_at: number | null;
            profile_picture_url: string | null;
        } | {
            type: "discord_oauth";
            email: string | null;
            username: string | null;
            subject: string;
            verified_at: number;
            first_verified_at: number | null;
            latest_verified_at: number | null;
        } | {
            type: "github_oauth";
            name: string | null;
            email: string | null;
            username: string | null;
            subject: string;
            verified_at: number;
            first_verified_at: number | null;
            latest_verified_at: number | null;
        } | {
            type: "linkedin_oauth";
            email: string | null;
            subject: string;
            verified_at: number;
            first_verified_at: number | null;
            latest_verified_at: number | null;
            name?: string | undefined;
            vanity_name?: string | undefined;
        } | {
            type: "spotify_oauth";
            name: string | null;
            email: string | null;
            subject: string;
            verified_at: number;
            first_verified_at: number | null;
            latest_verified_at: number | null;
        } | {
            type: "instagram_oauth";
            username: string | null;
            subject: string;
            verified_at: number;
            first_verified_at: number | null;
            latest_verified_at: number | null;
        } | {
            type: "tiktok_oauth";
            name: string | null;
            username: string | null;
            subject: string;
            verified_at: number;
            first_verified_at: number | null;
            latest_verified_at: number | null;
        } | {
            type: "apple_oauth";
            email: string | null;
            subject: string;
            verified_at: number;
            first_verified_at: number | null;
            latest_verified_at: number | null;
        } | {
            type: "custom_auth";
            verified_at: number;
            first_verified_at: number | null;
            latest_verified_at: number | null;
            custom_user_id: string;
        } | {
            type: "cross_app";
            subject: string;
            verified_at: number;
            first_verified_at: number | null;
            latest_verified_at: number | null;
            provider_app_id: string;
            embedded_wallets: {
                address: string;
            }[];
            smart_wallets: {
                address: string;
            }[];
        })[];
        created_at: number;
        has_accepted_terms: boolean;
        is_guest: boolean;
        custom_metadata?: Record<string, string> | undefined;
    }>;
};

interface UseOnEmbeddedWalletStateChange {
    onStateChange: (state: EmbeddedWalletState) => void;
}
/**
 * Attach callbacks for state changes on embedded wallets
 *
 * @example
 * useEmbeddedWalletStateChange({
 *   onStateChange: (state) => {
 *     if (state.status === 'not-created') {
 *       return router.replace('/create-wallet');
 *     }
 *
 *     if (state.status === 'connected') {
 *       return router.replace('/');
 *     }
 *   },
 * });
 */
declare const useEmbeddedWalletStateChange: ({ onStateChange }: UseOnEmbeddedWalletStateChange) => void;

declare const useIdentityToken: () => {
    getIdentityToken: () => Promise<string | null>;
};

type UseEmbeddedWallet = {
    /**
     * Callback function triggered when wallet creation is successful.
     * @param {PrivyEmbeddedWalletProvider} wallet - The created wallet.
     */
    onCreateWalletSuccess?: (wallet: PrivyEmbeddedWalletProvider) => void;
    /**
     * Callback function triggered when wallet creation encounters an error.
     * @param {Error} error - The error encountered during wallet creation.
     */
    onCreateWalletError?: (error: Error) => void;
    /**
     * Callback function triggered when wallet recovery is successful.
     * @param {PrivyEmbeddedWalletProvider} wallet - The recovered wallet.
     */
    onRecoverWalletSuccess?: (wallet: PrivyEmbeddedWalletProvider) => void;
    /**
     * Callback function triggered when wallet recovery encounters an error.
     * @param {Error} error - The error encountered during wallet recovery.
     */
    onRecoverWalletError?: (error: Error) => void;
    /**
     * Callback function triggered when wallet recovery upgrade is successful.
     * @param {PrivyEmbeddedWalletProvider} wallet - The wallet with upgrading recovery.
     */
    onSetWalletRecoverySuccess?: (wallet: PrivyEmbeddedWalletProvider) => void;
    /**
     * Callback function triggered when ugradinge wallet recovery encounters an error.
     * @param {Error} error - The error encountered during wallet recovery upgrade.
     */
    onSetWalletRecoveryError?: (error: Error) => void;
};
declare const useEmbeddedWallet: (props?: UseEmbeddedWallet) => EmbeddedWalletState;

type UseEmbeddedSolanaWallet = {
    /**
     * Callback function triggered when wallet creation is successful.
     * @param {PrivyEmbeddedSolanaWalletProvider} wallet - The created wallet.
     */
    onCreateWalletSuccess?: (wallet: PrivyEmbeddedSolanaWalletProvider) => void;
    /**
     * Callback function triggered when wallet creation encounters an error.
     * @param {Error} error - The error encountered during wallet creation.
     */
    onCreateWalletError?: (error: Error) => void;
    /**
     * Callback function triggered when wallet recovery is successful.
     * @param {PrivyEmbeddedWalletProvider} wallet - The recovered wallet.
     */
    onRecoverWalletSuccess?: (wallet: PrivyEmbeddedSolanaWalletProvider) => void;
    /**
     * Callback function triggered when wallet recovery encounters an error.
     * @param {Error} error - The error encountered during wallet recovery.
     */
    onRecoverWalletError?: (error: Error) => void;
};
declare const useEmbeddedSolanaWallet: (props?: UseEmbeddedSolanaWallet) => EmbeddedSolanaWalletState;

declare const usePrivyClient: () => Privy.default;

declare const usePrivy: () => {
    user: _privy_io_public_api.PrivyUser | null;
    isReady: boolean;
    logout: () => Promise<void>;
    getAccessToken: () => Promise<string | null>;
};

type PrivyContext = {
    client: Privy__default;
    user: PrivyUser | null;
    isReady: boolean;
    wallet: EmbeddedWalletState;
    solanaWallet: EmbeddedSolanaWalletState;
    otpState: OtpFlowState;
    setOtpState: React.Dispatch<React.SetStateAction<OtpFlowState>>;
    oAuthState: OAuthFlowState;
    setOAuthState: React.Dispatch<React.SetStateAction<OAuthFlowState>>;
    oAuthCallbacks: React.MutableRefObject<OAuthHookOptions | undefined>;
    oAuthStateRef: React.MutableRefObject<{
        disableSignup?: boolean;
    }>;
    createWalletCallbacks: React.MutableRefObject<WalletRecoveryCallbacks | undefined>;
    recoverWalletCallbacks: React.MutableRefObject<WalletRecoveryCallbacks | undefined>;
    setWalletRecoveryCallbacks: React.MutableRefObject<WalletRecoveryCallbacks | undefined>;
    createSolanaWalletCallbacks: React.MutableRefObject<SolanaWalletRecoveryCallbacks | undefined>;
    recoverSolanaWalletCallbacks: React.MutableRefObject<SolanaWalletRecoveryCallbacks | undefined>;
    recoveryFlowState: RecoveryFlowState;
    setRecoveryFlowState: React.Dispatch<React.SetStateAction<RecoveryFlowState>>;
    solanaRecoveryFlowState: RecoveryFlowState;
    setSolanaRecoveryFlowState: React.Dispatch<React.SetStateAction<RecoveryFlowState>>;
    siweState: SiweFlowState;
    setSiweState: React.Dispatch<React.SetStateAction<SiweFlowState>>;
    passkeyState: PasskeyFlowState;
    setPasskeyState: React.Dispatch<React.SetStateAction<PasskeyFlowState>>;
    farcasterState: FarcasterFlowState;
    setFarcasterState: React.Dispatch<React.SetStateAction<FarcasterFlowState>>;
    logout: () => Promise<void>;
    getAccessToken: () => Promise<string | null>;
    getIdentityToken: () => Promise<string | null>;
};
declare const PrivyContext: React.Context<PrivyContext>;
interface PrivyProviderProps {
    children: React.ReactNode;
    /**
     * Privy application ID _(can be found in privy developer dashboard)_
     */
    appId: string;
    /**
     * Privy client ID _(can be found in privy developer dashboard, in the clients section for each app)_
     */
    clientId?: string;
    /**
     * By default, the Privy SDK will store any persisted state in SecureStorage.
     * This behavior can be overridden by defining in a storage prop
     * that implements the privy `Storage` interface.
     *
     * @example
     * import type {Storage} from '@privy-io/expo';
     *
     * class OtherStorage implements Storage { ... }
     *
     * <PrivyProvider appId="<your-app-id>" storage={OtherStorage}>
     *   {children}
     * </PrivyProvider>
     */
    storage?: Storage;
    /**
     * A list of supported chains, used to specify which chains should be used throughout the application.
     * **Overrides the default list of supported chains.** Calling `sendTransaction` or `switchChain` on
     * an unsupported network will throw an error.
     *
     * For embedded wallets, the wallet will automatically default to the first supplied `supportedChain`.
     *
     * Defaults to:
     * - mainnet
     * - goerli
     * - sepolia
     * - arbitrum
     * - arbitrumGoerli
     * - optimism
     * - optimismGoerli
     * - polygon
     * - polygonMumbai
     * - celo
     * - celoAlfajores
     * - filecoin
     * - filecoinCalibration
     * - base
     * - baseGoerli
     * - linea
     * - lineaTestnet
     * - avalanche
     * - avalancheFuji
     * - holesky
     * - redstoneHolesky
     */
    supportedChains?: [Chain, ...Chain[]];
    config?: {
        customAuth?: CustomAuthProviderConfig;
    };
}
/**
 * Get the access token for the current user, if they are logged in.
 * This method will refresh the user's access token if is nearing expiration or has expired.
 * @returns The access token if the user is logged in, otherwise `null`.
 */
declare function getAccessToken(): Promise<string | null>;
declare const PrivyProvider: (props: PrivyProviderProps) => React.JSX.Element;

/**
 * @deprecated Use `LoginWithOAuthInput` or `LinkWithOAuthInput` instead
 */
type StartOAuthFlowArgs = {
    provider: OAuthProviderType;
    redirectUri?: string | undefined;
    /**
     * Enables legacy Apple OAuth on iOS.
     *
     * By default, Apple login on iOS will use the native Sign in with Apple functionality.
     * Enabling this flag will override this behavior to use the web-based OAuth flow, popping
     * up a webview for authentication.
     */
    isLegacyAppleIosBehaviorEnabled?: boolean;
};
/**
 * @deprecated Use `UseLoginWithOAuth` or `UseLinkWithOAuth` instead
 */
type OAuthFlowHookResult = {
    start: (input: StartOAuthFlowArgs) => Promise<PrivyUser | undefined>;
    state: OAuthFlowState;
};
type LoginWithOAuthInput = LinkWithOAuthInput & {
    disableSignup?: boolean;
};
interface UseLoginWithOAuth {
    state: OAuthFlowState;
    login: (input: LoginWithOAuthInput) => Promise<PrivyUser | undefined>;
}
/**
 * Returns a `login` function to initiate an oauth login flow, as well as the current state of oauth flow
 *
 * @example
 *
 * // Somewhere within a component tree wrapped with <PrivyProvider />
 * const {login, state} = useLoginWithOAuth()
 *
 * // Kick off an oauth flow
 * <Button onPress={() => login({ provider: 'google' })} /> *
 *
 * // Show a spinner during the transition
 * {state.status === 'loading' && <Spinner />}
 */
declare function useLoginWithOAuth(opts?: OAuthHookOptions): UseLoginWithOAuth;
type LinkWithOAuthInput = {
    provider: OAuthProviderType;
    redirectUri?: string | undefined;
    /**
     * Enables legacy Apple OAuth on iOS.
     *
     * By default, Apple login on iOS will use the native Sign in with Apple functionality.
     * Enabling this flag will override this behavior to use the web-based OAuth flow, popping
     * up a webview for authentication.
     */
    isLegacyAppleIosBehaviorEnabled?: boolean;
};
interface UseLinkWithOAuth {
    state: OAuthFlowState;
    link: (input: LinkWithOAuthInput) => Promise<PrivyUser | undefined>;
}
/**
 * Returns a `link` function to initiate an oauth link flow, as well as the current state of the oauth flow
 *
 * @example
 *
 * // Somewhere within a component tree wrapped with <PrivyProvider />
 * const {link, state} = useLinkWithOAuth()
 *
 * // Kick off an oauth flow
 * <Button onPress={() => link({ provider: 'google' })} />
 *
 * // Show a spinner during the transition
 * {state.status === 'loading' && <Spinner />}
 */
declare function useLinkWithOAuth(opts?: OAuthHookOptions): UseLinkWithOAuth;
/**
 * @deprecated use `useLoginWithOAuth` or `useLinkWithOAuth`
 *
 * Returns a `start` function to initiate an oauth flow as well as
 * the current state of oauth flow
 *
 * @example
 *
 * // Somewhere within a component tree wrapped with <PrivyProvider />
 * const {start, state} = usOAuthFlow()
 *
 * // Kick off an oauth flow
 * <Button onPress={() => start({ provider: 'google' })} />
 *
 * // Show a spinner during the transition
 * {state.status === 'loading' && <Spinner />}
 */
declare function useOAuthFlow(opts?: OAuthHookOptions): OAuthFlowHookResult;
/**
 * Storage adapter using `expo-secure-store` intended for
 * use with `Privy` class from `@privy-io/js-sdk-core`
 */
declare const SecureStorageAdapter: Storage;

export { EmbeddedSolanaWalletState, EmbeddedWalletState, LinkWithEmailHookResult, LinkWithEmailOptions, LinkWithOAuthInput, LinkWithSMSHookResult, LinkWithSMSOptions, LoginWithEmailHookResult, LoginWithEmailOptions, LoginWithOAuthInput, LoginWithSMSHookResult, LoginWithSMSOptions, OAuthFlowHookResult, OAuthFlowState, OtpFlowState, PrivyContext, PrivyProvider, PrivyProviderProps, RecoveryFlowState, SecureStorageAdapter, UseLinkWithFarcaster, UseLinkWithFarcasterOptions, UseLinkWithOAuth, UseLinkWithSiwe, UseLinkWithSiweOptions, UseLoginWithFarcaster, UseLoginWithFarcasterOptions, UseLoginWithOAuth, UseLoginWithSiwe, UseLoginWithSiweOptions, UseOnEmbeddedWalletStateChange, UseUnlinkFarcaster, UseUnlinkFarcasterOptions, UseUnlinkWallet, UseUnlinkWalletOptions, getAccessToken, useEmbeddedSolanaWallet, useEmbeddedWallet, useEmbeddedWalletStateChange, useIdentityToken, useLinkEmail, useLinkSMS, useLinkWithFarcaster, useLinkWithOAuth, useLinkWithSiwe, useLoginWithEmail, useLoginWithFarcaster, useLoginWithOAuth, useLoginWithSMS, useLoginWithSiwe, useOAuthFlow, usePrivy, usePrivyClient, useUnlinkFarcaster, useUnlinkOAuth, useUnlinkWallet };
