import { PrivyClientError, PrivyApiError, PrivyEmbeddedWalletProvider, PrivyEmbeddedSolanaWalletProvider, ExternalWallet } from '@privy-io/js-sdk-core';
import { PrivyAuthenticatedUser, PrivyUser, PrivySuccessObject, PrivyEthereumEmbeddedWalletAccount } from '@privy-io/public-api';

type EmbeddedWallet = Extract<PrivyAuthenticatedUser['user']['linked_accounts'][number], {
    wallet_client_type: 'privy';
    connector_type: 'embedded';
}>;
type User = PrivyAuthenticatedUser['user'];
type OAuthFlowState = {
    status: 'initial';
} | {
    status: 'loading';
} | {
    status: 'done';
} | {
    status: 'error';
    error: Error | null;
};
type CreateOrRecoverEmbeddedWalletProps = (string | undefined) | {
    recoveryMethod: 'privy';
} | {
    recoveryMethod: 'user-passcode';
    password: string;
} | {
    recoveryMethod: 'google-drive';
} | {
    recoveryMethod: 'icloud';
};
type SetRecoveryProps = {} | {
    recoveryMethod: 'user-passcode';
    password: string;
} | {
    recoveryMethod: 'google-drive' | 'icloud';
};
type RecoveryFlowState = {
    status: 'initial' | 'creating-wallet' | 'upgrading-recovery' | 'recovering';
};
type CustomAuthFlowState = {
    status: 'initial';
} | {
    status: 'loading';
} | {
    status: 'not-enabled';
} | {
    status: 'done';
} | {
    status: 'error';
    error: Error | null;
};

type OtpFlowState = {
    status: 'initial';
} | {
    status: 'error';
    error: Error | null;
} | {
    status: 'sending-code';
} | {
    status: 'awaiting-code-input';
} | {
    status: 'submitting-code';
} | {
    status: 'done';
};
type AuthSuccessCallback = (user: PrivyUser, isNewUser?: boolean) => void;
type AuthLinkSuccessCallback = (user: PrivyUser) => void;
type ErrorCallback = (error: PrivyClientError | PrivyApiError | Error) => void;
type OtpLoginHookOptions<AuthSourceArgs> = {
    onError?: ErrorCallback;
    onSendCodeSuccess?: (args: AuthSourceArgs) => void;
    onLoginSuccess?: AuthSuccessCallback;
};
type OtpLinkHookOptions<AuthSourceArgs> = {
    onError?: ErrorCallback;
    onSendCodeSuccess?: (args: AuthSourceArgs) => void;
    onLinkSuccess?: AuthLinkSuccessCallback;
};
type OtpLinkHookResult<SendArgs, LinkArgs> = {
    sendCode: (args: SendArgs) => Promise<PrivySuccessObject>;
    linkWithCode: (args: LinkArgs) => Promise<PrivyUser | undefined>;
    state: OtpFlowState;
};
type OtpLoginHookResult<SendArgs, LoginArgs> = {
    sendCode: (args: SendArgs) => Promise<PrivySuccessObject>;
    loginWithCode: (args: LoginArgs) => Promise<PrivyUser | undefined>;
    state: OtpFlowState;
};
type OAuthHookOptions = {
    onError?: ErrorCallback;
    onSuccess?: AuthSuccessCallback;
};
type WalletRecoveryCallbacks = {
    onError?: ErrorCallback;
    onSuccess?: (provider: PrivyEmbeddedWalletProvider) => void;
};
type SolanaWalletRecoveryCallbacks = {
    onError?: ErrorCallback;
    onSuccess?: (provider: PrivyEmbeddedSolanaWalletProvider) => void;
};
type SiweFlowState = {
    status: 'initial';
} | {
    status: 'error';
    error: Error | null;
} | {
    status: 'generating-message';
} | {
    status: 'awaiting-signature';
} | {
    status: 'submitting-signature';
} | {
    status: 'done';
};
/** [EIP-4361](https://eips.ethereum.org/EIPS/eip-4361) message to be used in signing */
type GenerateSiweMessageResponse = Promise<string>;
type GenerateSiweMessage = (opts: {
    /** Wallet to request a [Sign-In With Ethereum](https://eips.ethereum.org/EIPS/eip-4361) signature from */
    wallet: ExternalWallet;
    /**
     * Required fields that describe origin of [Sign-In With Ethereum](https://eips.ethereum.org/EIPS/eip-4361) signature request
     */
    from: {
        /** [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986) authority that is requesting the signing */
        domain: string;
        /** [RFC 3986](https://datatracker.ietf.org/doc/html/rfc3986) URI referring to the resource that is the subject of the signing */
        uri: string;
    };
}) => GenerateSiweMessageResponse;
type FarcasterFlowState = {
    status: 'initial';
} | {
    status: 'error';
    error: Error | null;
} | {
    status: 'generating-uri';
} | {
    status: 'awaiting-uri';
} | {
    status: 'polling-status';
} | {
    status: 'submitting-token';
} | {
    status: 'done';
};
type LoginWithFarcasterInput = {
    relyingParty?: string;
    /**
     * The URL path to redirect to after the Farcaster flow is complete.
     *
     * NOTE: This URL should be a deep link path that will open the app and handle the redirect. If
     * not provided it will default to the root path `/`.
     */
    redirectUrl?: string;
    disableSignup?: boolean;
};
type LinkFarcasterInput = {
    relyingParty?: string;
    /**
     * The URL path to redirect to after the Farcaster flow is complete.
     *
     * NOTE: This URL should be a deep link path that will open the app and handle the redirect. If
     * not provided it will default to the root path `/`.
     */
    redirectUrl?: string;
};
type SubmitFarcasterOptions = {
    pollIntervalMs: number;
    pollAttempts: number;
};
type PasskeyFlowState = {
    status: 'initial';
} | {
    status: 'error';
    error: Error | null;
} | {
    status: 'generating-challenege';
} | {
    status: 'awaiting-passkey';
} | {
    status: 'submitting-response';
} | {
    status: 'done';
};
type SubmitPasskeyInput = {
    /**
     * The URL associated with this app. See: https://w3c.github.io/webauthn/#relying-party
     *
     * It will be used by the operating system to verify the app association.
     * - On iOS via [apple-app-site-association](https://developer.apple.com/documentation/xcode/supporting-associated-domains)
     * - On Android via [assetlinks](https://developers.google.com/digital-asset-links/v1/getting-started)
     */
    relyingParty: string;
};
type SubmitPasskeySignature = (input: SubmitPasskeyInput) => Promise<PrivyUser | undefined>;
type PasskeyLoginHookOptions = {
    onError?: ErrorCallback;
    onSuccess?: AuthSuccessCallback;
};
type PasskeyLinkHookOptions = {
    onError?: ErrorCallback;
    onSuccess?: AuthLinkSuccessCallback;
};
type PasskeyHookResult<T extends 'login' | 'link'> = {
    state: PasskeyFlowState;
} & (T extends 'login' ? {
    loginWithPasskey: SubmitPasskeySignature;
} : {
    linkWithPasskey: SubmitPasskeySignature;
});

type IEmbeddedWalletConnectedState = {
    status: 'connected';
    provider: PrivyEmbeddedWalletProvider;
    account: PrivyEthereumEmbeddedWalletAccount;
};
type IEmbeddedWalletConnectingState = {
    status: 'connecting';
    account: PrivyEthereumEmbeddedWalletAccount;
};
type IEmbeddedWalletReconnectingState = {
    status: 'reconnecting';
    account: PrivyEthereumEmbeddedWalletAccount;
};
type IEmbeddedWalletDisconnectedState = {
    status: 'disconnected';
    account: null;
};
type IEmbeddedWalletNeedsRecoveryState = {
    status: 'needs-recovery';
    account: PrivyEthereumEmbeddedWalletAccount;
};
type IEmbeddedWalletNotCreatedState = {
    status: 'not-created';
    account: null;
};
type IEmbeddedWalletCreatingState = {
    status: 'creating';
    account: null;
};
type IEmbeddedWalletErrorState = {
    status: 'error';
    account: PrivyEthereumEmbeddedWalletAccount | null;
    error: string;
};
type EmbeddedWalletActions = {
    /**
     * Recover the user's embedded wallet
     *
     * @param {{ recoveryMethod: 'user-passcode'; password: string }} User password: Preferred version with 'user-passcode' recovery method. Password is user-defined.
     * @param {{ recoveryMethod: 'google-drive' | 'icloud' }} Recovery provider: 'google-drive' or 'icloud' recovery method. Password is generated and stored on the cloud provider.
     * @returns {Promise<PrivyEmbeddedWalletProvider | null>} The EIP-1193 provider. If using google-drive recovery on Android, this will return null due to an Android bug with AuthSession. Use the `recoverWalletCallbacks` to handle wallet creation success in such cases.
  
     */
    recover: (args?: CreateOrRecoverEmbeddedWalletProps) => Promise<PrivyEmbeddedWalletProvider | null>;
    /**
     * Create an embedded wallet for this user.
     *
     * @param {{ recoveryMethod: 'user-passcode'; password: string }} User password: Preferred version with 'user-passcode' recovery method. Password is user-defined.
     * @param {{ recoveryMethod: 'google-drive' | 'icloud' }} Recovery provider: 'google-drive' or 'icloud' recovery method. Password is generated and stored on the cloud provider.
     * @returns {Promise<PrivyEmbeddedWalletProvider | null>} The EIP-1193 provider. If using google-drive recovery on Android, this will return null due to an Android bug with AuthSession. Use the `createWalletCallbacks` to handle wallet creation success in such cases.
     */
    create: (args?: CreateOrRecoverEmbeddedWalletProps) => Promise<PrivyEmbeddedWalletProvider | null>;
    /**
     * Return an EIP-1193 Provider for the Privy embedded wallet.
     *
     * @returns {@link PrivyEmbeddedWalletProvider} the EIP-1193 provider
     */
    getProvider: () => Promise<PrivyEmbeddedWalletProvider>;
    /**
     * @deprecated. Use `setRecovery` instead.
     * Set recovery password for a user's existing embedded wallet
     *
     * @param newPassword A user-defined password
     * @returns {Promise<PrivyEmbeddedWalletProvider>} The EIP-1193 provider.
     */
    setPassword: (password: string) => Promise<PrivyEmbeddedWalletProvider>;
    /**
     * Sets recovery for a user's existing embedded wallet.
     *
     * @param {SetRecoveryProps} - An object containing the necessary properties for setting recovery.
     * @returns {Promise<PrivyEmbeddedWalletProvider | null>} - Returns a Promise that resolves to an EIP-1193 provider. If using Google Drive recovery on Android, this will return null due to an Android bug with AuthSession. Use the `setWalletRecoveryCallbacks` to handle wallet recovery setting success in such cases.
     */
    setRecovery: (args: SetRecoveryProps) => Promise<PrivyEmbeddedWalletProvider | null>;
};
type EmbeddedWalletConnectedState = EmbeddedWalletActions & IEmbeddedWalletConnectedState;
type EmbeddedWalletConnectingState = EmbeddedWalletActions & IEmbeddedWalletConnectingState;
type EmbeddedWalletReconnectingState = EmbeddedWalletActions & IEmbeddedWalletReconnectingState;
type EmbeddedWalletDisconnectedState = EmbeddedWalletActions & IEmbeddedWalletDisconnectedState;
type EmbeddedWalletNeedsRecoveryState = EmbeddedWalletActions & IEmbeddedWalletNeedsRecoveryState;
type EmbeddedWalletNotCreatedState = EmbeddedWalletActions & IEmbeddedWalletNotCreatedState;
type EmbeddedWalletCreatingState = EmbeddedWalletActions & IEmbeddedWalletCreatingState;
type EmbeddedWalletErrorState = EmbeddedWalletActions & IEmbeddedWalletErrorState;
type EmbeddedWalletState = EmbeddedWalletConnectedState | EmbeddedWalletConnectingState | EmbeddedWalletReconnectingState | EmbeddedWalletDisconnectedState | EmbeddedWalletNeedsRecoveryState | EmbeddedWalletCreatingState | EmbeddedWalletNotCreatedState | EmbeddedWalletErrorState;
type EmbeddedWalletStatus = EmbeddedWalletState['status'];

type IEmbeddedSolanaWalletConnectedState = {
    status: 'connected';
    publicKey: string;
};
type IEmbeddedSolanaWalletConnectingState = {
    status: 'connecting';
};
type IEmbeddedSolanaWalletReconnectingState = {
    status: 'reconnecting';
};
type IEmbeddedSolanaWalletDisconnectedState = {
    status: 'disconnected';
};
type IEmbeddedSolanaWalletNeedsRecoveryState = {
    status: 'needs-recovery';
};
type IEmbeddedSolanaWalletNotCreatedState = {
    status: 'not-created';
};
type IEmbeddedSolanaWalletCreatingState = {
    status: 'creating';
};
type IEmbeddedSolanaWalletErrorState = {
    status: 'error';
    error: string;
};
type EmbeddedSolanaWalletActions = {
    /**
     * Recover the user's embedded wallet
     *
     * @returns {Promise<PrivyEmbeddedSolanaWalletProvider | null>} The provider.
  
     */
    recover: () => Promise<PrivyEmbeddedSolanaWalletProvider | null>;
    /**
     * Create an embedded wallet for this user.
     *
     * @returns {Promise<PrivyEmbeddedSolanaWalletProvider | null>} The provider. If using google-drive recovery on Android, this will return null due to an Android bug with AuthSession. Use the `createSolanaWalletCallbacks` to handle wallet creation success in such cases.
     */
    create: (args?: CreateOrRecoverEmbeddedWalletProps) => Promise<PrivyEmbeddedSolanaWalletProvider | null>;
    /**
     * Return a provider for the Privy embedded wallet.
     *
     * @returns {@link PrivyEmbeddedSolanaWalletProvider} the Phantom provider
     */
    getProvider: () => Promise<PrivyEmbeddedSolanaWalletProvider>;
};
type EmbeddedSolanaWalletConnectedState = EmbeddedSolanaWalletActions & IEmbeddedSolanaWalletConnectedState;
type EmbeddedSolanaWalletConnectingState = EmbeddedSolanaWalletActions & IEmbeddedSolanaWalletConnectingState;
type EmbeddedSolanaWalletReconnectingState = EmbeddedSolanaWalletActions & IEmbeddedSolanaWalletReconnectingState;
type EmbeddedSolanaWalletDisconnectedState = Partial<EmbeddedSolanaWalletActions> & IEmbeddedSolanaWalletDisconnectedState;
type EmbeddedSolanaWalletNeedsRecoveryState = EmbeddedSolanaWalletActions & IEmbeddedSolanaWalletNeedsRecoveryState;
type EmbeddedSolanaWalletNotCreatedState = EmbeddedSolanaWalletActions & IEmbeddedSolanaWalletNotCreatedState;
type EmbeddedSolanaWalletCreatingState = EmbeddedSolanaWalletActions & IEmbeddedSolanaWalletCreatingState;
type EmbeddedSolanaWalletErrorState = EmbeddedSolanaWalletActions & IEmbeddedSolanaWalletErrorState;
type EmbeddedSolanaWalletState = EmbeddedSolanaWalletConnectedState | EmbeddedSolanaWalletConnectingState | EmbeddedSolanaWalletReconnectingState | EmbeddedSolanaWalletDisconnectedState | EmbeddedSolanaWalletNeedsRecoveryState | EmbeddedSolanaWalletCreatingState | EmbeddedSolanaWalletNotCreatedState | EmbeddedSolanaWalletErrorState;
type EmbeddedSolanaWalletStatus = EmbeddedSolanaWalletState['status'];

declare function isConnected(s: EmbeddedWalletState): s is EmbeddedWalletConnectedState;
declare function isConnected(s: EmbeddedSolanaWalletState): s is EmbeddedSolanaWalletConnectedState;
declare function isReconnecting(s: EmbeddedWalletState): s is EmbeddedWalletReconnectingState;
declare function isReconnecting(s: EmbeddedSolanaWalletState): s is EmbeddedSolanaWalletReconnectingState;
declare function isConnecting(s: EmbeddedWalletState): s is EmbeddedWalletConnectingState;
declare function isConnecting(s: EmbeddedSolanaWalletState): s is EmbeddedSolanaWalletConnectingState;
declare function isDisconnected(s: EmbeddedWalletState): s is EmbeddedWalletDisconnectedState;
declare function isDisconnected(s: EmbeddedSolanaWalletState): s is EmbeddedSolanaWalletDisconnectedState;
declare function isNotCreated(s: EmbeddedWalletState): s is EmbeddedWalletNotCreatedState;
declare function isNotCreated(s: EmbeddedSolanaWalletState): s is EmbeddedSolanaWalletNotCreatedState;
declare function isCreating(s: EmbeddedWalletState): s is EmbeddedWalletCreatingState;
declare function isCreating(s: EmbeddedSolanaWalletState): s is EmbeddedSolanaWalletCreatingState;
declare function hasError(s: EmbeddedWalletState): s is EmbeddedWalletErrorState;
declare function hasError(s: EmbeddedSolanaWalletState): s is EmbeddedSolanaWalletErrorState;
declare function needsRecovery(s: EmbeddedWalletState): s is EmbeddedWalletNeedsRecoveryState;
declare function needsRecovery(s: EmbeddedSolanaWalletState): s is EmbeddedSolanaWalletNeedsRecoveryState;

export { AuthLinkSuccessCallback as A, needsRecovery as B, CreateOrRecoverEmbeddedWalletProps as C, PasskeyLinkHookOptions as D, ErrorCallback as E, FarcasterFlowState as F, GenerateSiweMessage as G, PasskeyHookResult as H, PasskeyLoginHookOptions as I, LinkFarcasterInput as L, OtpLinkHookOptions as O, PasskeyFlowState as P, RecoveryFlowState as R, SiweFlowState as S, User as U, WalletRecoveryCallbacks as W, AuthSuccessCallback as a, OtpLinkHookResult as b, OtpLoginHookOptions as c, OtpLoginHookResult as d, SubmitFarcasterOptions as e, LoginWithFarcasterInput as f, OAuthHookOptions as g, EmbeddedWalletState as h, EmbeddedSolanaWalletState as i, OtpFlowState as j, OAuthFlowState as k, SolanaWalletRecoveryCallbacks as l, EmbeddedWallet as m, SetRecoveryProps as n, CustomAuthFlowState as o, EmbeddedWalletActions as p, EmbeddedWalletStatus as q, EmbeddedSolanaWalletActions as r, EmbeddedSolanaWalletStatus as s, isConnected as t, isReconnecting as u, isConnecting as v, isDisconnected as w, isNotCreated as x, isCreating as y, hasError as z };
